---
title: "presentation-exercise.qmd"
author: Murtaza Yaqubi
date: 02/12/2025
format: html
editor: visual
---

### Introduction:

I am planning to recreate a figure and a table using two distinct data sets. For the graphical component, I selected a dataset from FiveThirtyEight that details the number of Uber and other taxi services in New York City, comparing identical periods in 2014 and 2015. I accessed and downloaded the data from a GitHub repository, which you can visit to explore the dataset further at: <https://github.com/fivethirtyeight/uber-tlc-foil-response/tree/master/uber-trip-data>

I utilized ChatGPT's assistance to recreate the graph. Due to limitations regarding the number of files and their sizes, I couldn't directly upload the data for ChatGPT to replicate the graph. Instead, I supplied an image of the graph. I made several adjustments, undergoing seven iterations of the code, to fine-tune the graph so that it closely resembled the original.

I will provide details of three specific iterations, including the prompts I gave to ChatGPT to generate the code for each.

### First iteration:

### prompt:

You are an expert in replicating graphs and charts from images using R. I have an image of a graph that I would like to recreate as accurately as possible using R code. Please provide the complete R code along with detailed explanations to help me replicate the graph exactly as shown in the image.

### Original graph:

![](figure/uber-seasonalchange-1.png.webp)

### Output:

```{r}
# Load required packages
library(ggplot2)

# Create the dataset
data <- data.frame(
  Year = rep(c(2014, 2015), each = 3),
  Pickups = c(42, 38, 4, 5, 2, 8),  # Yellow Cabs, Green Cabs, Uber
  Type = rep(c("Yellow Cabs", "Green Cabs", "Uber"), times = 2)
)

# Plot using ggplot2
ggplot(data, aes(x = Year, y = Pickups, group = Type, color = Type)) +
  geom_line(size = 1.2) +  # Line thickness
  geom_point(size = 3) +   # Add points for clarity
  scale_color_manual(values = c("Yellow Cabs" = "orange", "Green Cabs" = "green", "Uber" = "purple")) +
  scale_x_continuous(breaks = c(2014, 2015)) +
  scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 10)) +
  labs(
    title = "Change in NYC Pickups",
    subtitle = "April-June 2014 versus April-June 2015",
    caption = "Source: Taxi & Limousine Commission",
    x = NULL, 
    y = NULL
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 14),
    plot.caption = element_text(size = 10, color = "gray50"),
    legend.title = element_blank(),
    legend.position = "bottom"
  )

```

In the output, the graph generated by the initial codes did not accurately replicate the original. Consequently, I prompted ChatGPT to further refine the codes, aiming to enhance the accuracy of the graph's replication.

### Second iteration:

Your attempt was close, but the data points for the different colored lines do not match the reference graph I provided earlier. I've attached the plot produced by your code alongside the reference graph. Please compare them to identify the discrepancies and adjust your code accordingly so that it replicates the graph as accurately as possible.

### Output:

```{r}
# Load required libraries
library(ggplot2)

# Create the corrected dataset
data <- data.frame(
  Year = rep(c(2014, 2015), each = 3),
  Pickups = c(42, 38, 4, 5, 2, 8),  # Corrected values
  Type = rep(c("Yellow Cabs", "Green Cabs", "Uber"), times = 2)
)

# Create the plot
ggplot(data, aes(x = Year, y = Pickups, group = Type, color = Type)) +
  geom_line(size = 1.5) +  # Adjust line thickness
  geom_point(size = 4) +   # Add points for emphasis
  scale_color_manual(values = c("Yellow Cabs" = "orange", "Green Cabs" = "green", "Uber" = "purple")) +
  scale_x_continuous(breaks = c(2014, 2015)) +
  scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, by = 10)) +
  labs(
    title = "Change in NYC Pickups",
    subtitle = "April-June 2014 versus April-June 2015",
    caption = "Source: Taxi & Limousine Commission",
    x = NULL, 
    y = NULL
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 14),
    plot.caption = element_text(size = 10, color = "gray50"),
    legend.title = element_blank(),
    legend.position = "bottom"
  )

```

### Final iteration:

Great progress! The start and finish points are exactly where they should be. Please keep that part of the code unchanged. Now, I need a few adjustments to the axes. For the x axis, display only two tick marks: one at 2014 and one at 2015, with nothing in between. For the y axis, show only the starting points of the lines and remove all other tick labels, so that the graph closely matches the target. Could you update the code accordingly and display the updated code in the side window alongside your previous version?

### Output:

```{r}
library(ggplot2)

# Data for each line plotted separately
data <- data.frame(
  Year = rep(c(2014, 2015), times = 4),
  Pickups = c(48, 51, 42, 38, 4, 5, 2, 8),
  Type = rep(c("Cabs + Uber", "Yellow Cabs", "Green Cabs", "Uber"), each = 2)
)

# Define colors for each category
colors <- c("Cabs + Uber" = "gray40", "Yellow Cabs" = "orange", "Green Cabs" = "limegreen", "Uber" = "purple")

# Format pickups with 'm' for million
data$Pickups_label <- paste0(data$Pickups, " m")

# Plot the graph
p <- ggplot(data, aes(x = Year, y = Pickups, group = Type, color = Type)) +
  geom_line(size = 1.2) +
  geom_point(size = 4, aes(color = Type)) +  # Ensure points match line colors
  geom_text(data = data[data$Year == 2014, ], aes(label = Pickups_label, color = Type), hjust = 1.3, size = 5) +  # Color-match labels for 2014 with 'm'
  scale_color_manual(values = colors) +
  scale_x_continuous(breaks = c(2014, 2015)) +
  scale_y_continuous(breaks = NULL) +  # Remove 2014 values from y-axis
  geom_vline(xintercept = c(2014, 2015), linetype = "solid", color = "black") +  # Change vertical lines to solid
  geom_text(data = data[data$Year == 2015, ], aes(label = Pickups_label, color = Type), hjust = -0.3, size = 5) +  # Move 2015 values to vertical line with matching colors and 'm'
  labs(
    title = "Change in NYC Pickups",
    subtitle = "April-June 2014 versus April-June 2015",
    x = "",
    y = "",
    caption = "Source: Taxi & Limousine Commission"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    legend.title = element_blank(),
    legend.position = "bottom",
    legend.text = element_text(size = 12),
    panel.grid = element_blank()  # Remove grid lines
  )

print(p)

```

Note: Please use the zoomed view to ensure you can see the entire graph clearly.

### Second part of the exercise:

For this segment of the exercise, I selected a dataset on the Case-Shiller Index, which tracks US residential house prices. This data, sourced from the S&P Case-Shiller, encompasses the national index as well as indices for 20 metropolitan regions. The indices employ a repeat-sales methodology to measure changes in house prices. The dataset is accessible via the following link: https://datahub.io/core/house-prices-us#cities-sa

Since I had no prior experience in creating graphs, I sought assistance from ChatGPT to help me navigate through the process. Utilizing its capabilities allowed me to better understand the steps involved in visual data representation.

### Prompt:

As an expert in generating statistical tables using R, your task is to create a comprehensive table from the provided dataset. This table should include the mean and standard deviation for each variable, as well as visually depict the trends through sparkline graphs. Please ensure each variable's statistics and corresponding trend are accurately represented.

```{r}
# Install packages
options(repos = c(CRAN = "https://cloud.r-project.org/"))
install.packages("DT")
install.packages("sparkline")
install.packages("png")
install.packages("kableExtra")
install.packages("base64enc")


# Load necessary libraries
library(here)
library(grid)
library(dplyr)
library(tidyr)
library(DT)
library(ggplot2)
library(sparkline)
library(png)
library(tidyverse)
library(kableExtra)
library(gridExtra)
library(grid)
library(base64enc)
library(htmltools)

# Read and clean the dataset
home_prices <- read.csv('data/flat-ui__data-Wed Feb 12 2025.csv')
home_prices$Date <- as.Date(home_prices$Date)

# Select columns and calculate mean and standard deviation
selected_columns <- c("AZ.Phoenix", "CA.Los.Angeles", "CA.San.Francisco", "NY.New.York", "CO.Denver", "DC.Washington", "FL.Miami", "GA.Atlanta", "IL.Chicago", "MA.Boston", "MI.Detroit", "MN.Minneapolis", "NC.Charlotte", "NV.Las.Vegas", "NY.New.York", "OH.Cleveland", "OR.Portland", "TX.Dallas", "WA.Seattle", "Composite.10", "Composite.20", "National.US"  )

# Calculate mean and standard deviation for all numeric columns
statistics <- home_prices %>%
  select(all_of(selected_columns)) %>%
  summarise(across(everything(), list(mean = mean, sd = sd), .names = "{.col}_{.fn}"))

# Transform statistics for easier management in tables
statistics_wide <- statistics %>%
  pivot_longer(cols = everything(), names_to = "Metric", values_to = "Value") %>%
  separate(Metric, into = c("Location", "Statistic"), sep = "_") %>%
  pivot_wider(names_from = Statistic, values_from = Value)

# Convert data for sparklines
sparkline_data <- home_prices %>% 
  select(all_of(selected_columns)) %>%
  pivot_longer(cols = everything(), names_to = "Location", values_to = "Values")

# Generate sparkline plots
generate_sparkline <- function(values) {
  p <- ggplot(data.frame(x = 1:length(values), y = values), aes(x = x, y = y)) +
    geom_line(color = "blue", linewidth = 1) +
    theme_void() +
    theme(plot.margin = unit(c(0, 0, 0, 0), "null"))
  return(p)
}

# Apply the function and capture plots
sparkline_plots <- lapply(split(sparkline_data$Values, sparkline_data$Location), generate_sparkline)


# Adjusting the code for creating and embedding sparkline images
sparkline_images <- lapply(sparkline_plots, function(p) {
  # Create a temporary file to store the plot
  tmp <- tempfile(fileext = ".png")
  
  # Save the plot to a PNG file with desired dimensions
  ggsave(tmp, plot = p, device = "png", width = 2, height = 0.5, dpi = 300)
  
  # Read the PNG file and encode it to base64
  img_data <- readBin(tmp, 'raw', n = file.info(tmp)$size)
  encoded <- sprintf('<img src="data:image/png;base64,%s" style="width:100px; height:30px;" />', base64enc::base64encode(img_data))
  
  # Clean up the temporary file
  unlink(tmp)
  
  # Return the HTML image tag with specified style attributes, ensuring there are no extra HTML tags
  encoded
})

# Now, ensure your data frame that goes into kableExtra is properly formatted
statistics_wide$Trend <- sparkline_images

# build final table with kableExtra
final_table <- statistics_wide %>%
  kable("html", escape = FALSE, align = 'c') %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  add_header_above(c(" " = 1, "Mean" = 1, "Standard Deviation" = 1, "Trend" = 1)) %>%
  row_spec(0, bold = TRUE, color = "blue") %>%
  column_spec(4, width = "100px") %>%  # Set width or other properties but not 'html = TRUE'
  footnote(general_title = "Note:", general = c("Mean and Standard Deviation are calculated from the entire dataset's history.",
                                                "Trends are displayed as sparklines."))

# Output the final table
browsable(final_table)


```
